# 15650.N과 M (2)

## 문제 링크

(https://www.acmicpc.net/problem/15650)

## 접근 방법

### 멀티 트리 형태로 풀기

멀티 트리 형태로 풀 경우 [15649.N과 M (1)](<../15649.N과%20M%20(1)/README.md>) 문제와 매우 유사하게 풀 수 있다.

똑같이 백트래킹을 진행하되, 다음 숫자를 선택할 때 모든 숫자를 선택하는 것이 아니라 `이전에 선택했던 수보다 큰 수`를 선택하면 된다.

### 이진 트리 형태로 풀기

이진 트리 형태로 풀 경우 이해하기도 쉽고 코드가 아주 간단해진다.

우선, 백트래킹을 진행할 함수를 만든다.

```python
def dfs(n, lst):
    # 나머지 코드
```

1부터 N까지 각 숫자를 선택하는 상황, 선택하지 않는 상황으로 나눠서 문제를 해결한다. 함수 파라미터에 있는 n은 선택할지 말지 고려해야 할 숫자이고, lst는 지금까지 선택된 숫자들의 리스트이다.

```python
if n > N:
    if len(lst) == M:
        print(*lst)
    return
```

dfs 함수의 `종료 조건`이다. n이 N을 초과할 수는 없으므로 무조건 종료시켜준다. 이때, 선택된 수의 개수가 M과 같으면 문제 조건에 맞는 수열이므로 출력해 준다.

```python
dfs(n + 1, lst + [n])
dfs(n + 1, lst)
```

첫 번째 호출은 n을 선택했을 때, 두 번째 호출은 n을 호출하지 않았을 때이다. 선택 유무에 상관없이 다음 숫자를 생각해야 하므로 둘 다 `n + 1`을 해준다.

이렇게 하면 함수 구현은 끝이다. 다음은 함수의 첫 번째 호출 코드를 살펴보자

```python
dfs(1, [])
```

처음 생각해야 할 수는 1이므로 n 자리에는 `1`을 넣어주고, 처음에는 선택된 수가 없으므로 lst 자리에 `[]`(빈 배열)을 넣어준다.

이해가 되지 않는다면 참고 자료에 있는 유튜브 영상에 자세히 설명되어 있으니 참고할 것.

## 참고 자료

- (https://youtu.be/WUq13ACJmB8?si=yqHk9OCLkQB8eh39)
