# 24416.알고리즘 수업 - 피보나치 수 1

## 문제 링크

(https://www.acmicpc.net/problem/24416)

## 접근 방법

### 피보나치 수 재귀호출

```
fib(n) {
    if (n = 1 or n = 2)
    then return 1;  # 코드1
    else return (fib(n - 1) + fib(n - 2));
}
```

**_(피보나치 수 재귀호출 의사코드)_**

문제에 나와있는 의사 코드를 그대로 코드로 구현하고 카운트만 해주면 쉽게 풀리는 문제다. 하지만 재귀 호출 코드는 그대로 사용하면 시간 초과가 나올 수 있기 때문에 동적 계획법을 이용하여 풀어야 한다.

재귀 호출 함수를 파라미터 n과 함께 돌렸을 때 수행되는 횟수를 `count(n)`, 리턴되는 값이 `fib(n)`이라고 하자. 재귀 호출 함수를 동적 계획법을 이용하여 해결하기 위해 `모든 자연수 n에 대하여 count(n) = fib(n)임을 증명`해야 한다.

자연수 k에 대해 `count(k) = fib(k)이라고 가정`하고 count(n+1)을 구해보자. 재귀 호출 함수 코드에 따르면 `count(k+1) = count(k) + count(k-1)`을 구할 수 있고, 이를 귀납 가정을 사용하여 다시 표현하면 `count(k+1) = fib(k) + fib(k-1)`이 된다.

피보나치 수열의 정의에 따르면 fib(k+1) = fib(k) + fib(k-1)이므로 `count(k+1) = fib(k+1)`이 성립함을 알 수 있다. 따라서 `모든 자연수 n에 대하여 count(n) = fib(n)`임을 증명할 수 있다.

재귀 호출 함수가 실행되는 횟수와 구해지는 피보나치 수가 같기 때문에 재귀 호출을 하지 않고 동적 계획법으로 피보나치 수를 구한 후 리턴하면 된다.

### 피보나치 수 동적 프로그래밍

```
fibonacci(n) {
    f[1] <- f[2] <- 1;
    for i <- 3 to n
        f[i] <- f[i - 1] + f[i - 2];  # 코드2
    return f[n];
}
```

**_(피보나치 수 동적 프로그래밍 의사코드)_**

위 함수는 n이 3이상일 때 n번 n-2번 실행된다는 특징을 가지고 있다. 문제에 나와있는 입력 조건이 5이상 이므로 이 문제에서 입력되는 모든 n에 대하여 위 함수의 실행 횟수는 n-2가 된다. 따라서 그냥 `n-2`를 출력하면 된다.
